
  ERC721PsiUpgradeable
    with no minted tokens
      âœ“ has 0 totalSupply
    with minted tokens
      âœ“ has 6 totalSupply
      exists
        âœ“ verifies valid tokens
        âœ“ verifies invalid tokens
      balanceOf
        âœ“ returns the amount for a given address

        1) throws an exception for the 0 address

Â·--------------------------------------------------------|---------------------------|-------------|------------------------------Â·
|                  [90mSolc version: 0.8.17[39m                  Â·  [90mOptimizer enabled: true[39m  Â·  [90mRuns: 200[39m  Â·  [90mBlock limit: 120000000 gas[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [32m[1mMethods[22m[39m                                                                                                                        â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [1mContract[22m                                 Â·  [1mMethod[22m    Â·  [32mMin[39m        Â·  [32mMax[39m        Â·  [32mAvg[39m        Â·  [1m# calls[22m      Â·  [1meur (avg)[22m   â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [90mERC721PsiDiamondMockUpgradeableWithInit[39m  Â·  safeMint  Â·      [36m62030[39m  Â·      [31m94309[39m  Â·      73438  Â·           [90m15[39m  Â·           [32m[90m-[32m[39m  â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  [32m[1mDeployments[22m[39m                                           Â·                                         Â·  [1m% of limit[22m   Â·              â”‚
Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·|Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
|  ERC721PsiDiamondMockUpgradeableWithInit               Â·          -  Â·          -  Â·    1549384  Â·        [90m1.3 %[39m  Â·           [32m[90m-[32m[39m  â”‚
Â·--------------------------------------------------------|-------------|-------------|-------------|---------------|--------------Â·

  5 passing (4s)
  1 failing

  1) ERC721PsiUpgradeable
       with minted tokens
         balanceOf
           throws an exception for the 0 address:
     AssertionError: Expected transaction to be reverted with ERC721Psi: balance query for the zero address, but other exception was thrown: Error: missing revert data in call exception; Transaction reverted without a reason string [ See: https://links.ethers.org/v5-errors-CALL_EXCEPTION ] (data="0x", transaction={"from":"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266","gasLimit":{"type":"BigNumber","hex":"0x07181f58"},"to":"0x9A9f2CCfdE556A7E9Ff0848998Aa4a0CFD8863AE","data":"0x70a082310000000000000000000000000000000000000000000000000000000000000000","accessList":null}, error={"stackTrace":[{"type":6,"sourceReference":{"function":"balanceOf","contract":"ERC721PsiDiamondMockUpgradeableWithInit","sourceName":"contracts/ERC721PsiDiamondUpgradeable.sol","sourceContent":"// SPDX-License-Identifier: MIT\n/**\n  ______ _____   _____ ______ ___  __ _  _  _ \n |  ____|  __ \\ / ____|____  |__ \\/_ | || || |\n | |__  | |__) | |        / /   ) || | \\| |/ |\n |  __| |  _  /| |       / /   / / | |\\_   _/ \n | |____| | \\ \\| |____  / /   / /_ | |  | |   \n |______|_|  \\_\\\\_____|/_/   |____||_|  |_|   \n\n - github: https://github.com/estarriolvetch/ERC721Psi\n - npm: https://www.npmjs.com/package/erc721psi\n                                          \n */\n\npragma solidity ^0.8.0;\n\nimport \"./interface/IERC721Psi.sol\";\nimport {ERC721PsiStorage} from \"./storage/ERC721PsiStorage.sol\";\nimport \"./storage/ERC721PsiInitializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"solidity-bits/contracts/BitMaps.sol\";\n\ninterface ERC721PsiUpgradeable__IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ncontract ERC721PsiDiamondUpgradeable is ERC721PsiInitializable, IERC721Psi {\n    using ERC721PsiStorage for ERC721PsiStorage.Layout;\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    using BitMaps for BitMaps.BitMap;\n\n    // The mask of the lower 160 bits for addresses.\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\n    // The `Transfer` event signature is given by:\n    // `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721PsiDiamond_init(string memory name_, string memory symbol_) internal onlyInitializingERC721Psi {\n        __ERC721PsiDiamond_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721PsiDiamond_init_unchained(string memory name_, string memory symbol_) internal onlyInitializingERC721Psi {\n        ERC721PsiStorage.layout()._name = name_;\n        ERC721PsiStorage.layout()._symbol = symbol_;\n        ERC721PsiStorage.layout()._currentIndex = _startTokenId();\n    }\n\n    /**\n     * @dev Returns the starting token ID.\n     * To change the starting token ID, please override this function.\n     */\n    function _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Returns the next token ID to be minted.\n     */\n    function _nextTokenId() internal view virtual returns (uint256) {\n        return ERC721PsiStorage.layout()._currentIndex;\n    }\n\n    /**\n     * @dev Returns the total amount of tokens minted in the contract.\n     */\n    function _totalMinted() internal view virtual returns (uint256) {\n        unchecked {\n            return ERC721PsiStorage.layout()._currentIndex - _startTokenId();       \n        }\n    }\n\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        // The interface IDs are constants representing the first 4 bytes\n        // of the XOR of all function selectors in the interface.\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) \n        public \n        view \n        virtual \n        override \n        returns (uint) \n    {\n        if(owner == address(0)) revert BalanceQueryForZeroAddress();\n\n        uint count;\n        for( uint i = _startTokenId(); i < _nextTokenId(); ++i ){\n            if(_exists(i)){\n                if( owner == ownerOf(i)){\n                    ++count;\n                }\n            }\n        }\n        return count;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        (address owner, ) = _ownerAndBatchHeadOf(tokenId);\n        return owner;\n    }\n\n    function _ownerAndBatchHeadOf(uint256 tokenId) internal view returns (address owner, uint256 tokenIdBatchHead){\n        if (!_exists(tokenId)) revert OwnerQueryForNonexistentToken();\n        tokenIdBatchHead = _getBatchHead(tokenId);\n        owner = ERC721PsiStorage.layout()._owners[tokenIdBatchHead];\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return ERC721PsiStorage.layout()._name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return ERC721PsiStorage.layout()._symbol;\n    }\n\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public payable virtual override {\n        address owner = ownerOf(tokenId);\n\n        if (_msgSenderERC721Psi() != owner) {\n            if (!isApprovedForAll(owner, _msgSenderERC721Psi())) {\n                revert ApprovalCallerNotOwnerNorApproved();\n            }\n        }\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (address) \n    {\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\n\n        return ERC721PsiStorage.layout()._tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved)\n        public\n        virtual\n        override\n    {\n        ERC721PsiStorage.layout()._operatorApprovals[_msgSenderERC721Psi()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721Psi(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return ERC721PsiStorage.layout()._operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable virtual override {\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public payable virtual override {\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        if (!_checkOnERC721Received(from, to, tokenId, 1, _data)) {\n            revert TransferToNonERC721ReceiverImplementer();\n        }\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return tokenId < _nextTokenId() && _startTokenId() <= tokenId;\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721Psi: operator query for nonexistent token\"\n        );\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 quantity) internal virtual {\n        _safeMint(to, quantity, \"\");\n    }\n\n    \n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, quantity);\n        uint256 end = ERC721PsiStorage.layout()._currentIndex;\n        if (!_checkOnERC721Received(address(0), to, end - quantity, quantity, _data)) {\n            revert TransferToNonERC721ReceiverImplementer();\n        }\n        // Reentrancy protection.\n        if (ERC721PsiStorage.layout()._currentIndex != end) revert();\n    }\n\n\n    function _mint(\n        address to,\n        uint256 quantity\n    ) internal virtual {\n        uint256 nextTokenId = _nextTokenId();\n        \n        if (quantity == 0) revert MintZeroQuantity();\n        if (to == address(0)) revert MintToZeroAddress();\n        \n        _beforeTokenTransfers(address(0), to, nextTokenId, quantity);\n        ERC721PsiStorage.layout()._currentIndex += quantity;\n        ERC721PsiStorage.layout()._owners[nextTokenId] = to;\n        ERC721PsiStorage.layout()._batchHead.set(nextTokenId);\n\n        uint256 toMasked;\n        uint256 end = nextTokenId + quantity;\n\n        // Use assembly to loop and emit the `Transfer` event for gas savings.\n        // The duplicated `log4` removes an extra check and reduces stack juggling.\n        // The assembly, together with the surrounding Solidity code, have been\n        // delicately arranged to nudge the compiler into producing optimized opcodes.\n        assembly {\n            // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\n            toMasked := and(to, _BITMASK_ADDRESS)\n            // Emit the `Transfer` event.\n            log4(\n                0, // Start of data (0, since no data).\n                0, // End of data (0, since no data).\n                _TRANSFER_EVENT_SIGNATURE, // Signature.\n                0, // `address(0)`.\n                toMasked, // `to`.\n                nextTokenId // `tokenId`.\n            )\n\n            // The `iszero(eq(,))` check ensures that large values of `quantity`\n            // that overflows uint256 will make the loop run out of gas.\n            // The compiler will optimize the `iszero` away for performance.\n            for {\n                let tokenId := add(nextTokenId, 1)\n            } iszero(eq(tokenId, end)) {\n                tokenId := add(tokenId, 1)\n            } {\n                // Emit the `Transfer` event. Similar to above.\n                log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\n            }\n        }\n\n        _afterTokenTransfers(address(0), to, nextTokenId, quantity);\n    }\n\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n\n        (address owner, uint256 tokenIdBatchHead) = _ownerAndBatchHeadOf(tokenId);\n\n        if (owner != from) revert TransferFromIncorrectOwner();\n\n        if (!_isApprovedOrOwner(_msgSenderERC721Psi(), tokenId)) {\n            revert TransferCallerNotOwnerNorApproved();\n        }\n\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);   \n\n        uint256 subsequentTokenId = tokenId + 1;\n\n        if(!ERC721PsiStorage.layout()._batchHead.get(subsequentTokenId) &&  \n            subsequentTokenId < _nextTokenId()\n        ) {\n            ERC721PsiStorage.layout()._owners[subsequentTokenId] = from;\n            ERC721PsiStorage.layout()._batchHead.set(subsequentTokenId);\n        }\n\n        ERC721PsiStorage.layout()._owners[tokenId] = to;\n        if(tokenId != tokenIdBatchHead) {\n            ERC721PsiStorage.layout()._batchHead.set(tokenId);\n        }\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        ERC721PsiStorage.layout()._tokenApprovals[tokenId] = to;\n        emit Approval(ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param startTokenId uint256 the first ID of the tokens to be transferred\n     * @param quantity uint256 amount of the tokens to be transfered.\n     * @param _data bytes optional data to send along with the call\n     * @return r bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity,\n        bytes memory _data\n    ) private returns (bool r) {\n        if (to.isContract()) {\n            r = true;\n            for(uint256 tokenId = startTokenId; tokenId < startTokenId + quantity; tokenId++){\n                try ERC721PsiUpgradeable__IERC721Receiver(to).onERC721Received( _msgSenderERC721Psi(), from, tokenId, _data) returns (bytes4 retval) {\n                    r = r && retval == ERC721PsiUpgradeable__IERC721Receiver.onERC721Received.selector;\n                } catch (bytes memory reason) {\n                    if (reason.length == 0) {\n                        revert TransferToNonERC721ReceiverImplementer();\n                    } else {\n                        assembly {\n                            revert(add(32, reason), mload(reason))\n                        }\n                    }\n                }\n            }\n            return r;\n        } else {\n            return true;\n        }\n    }\n\n    function _getBatchHead(uint256 tokenId) internal view returns (uint256 tokenIdBatchHead) {\n        tokenIdBatchHead = ERC721PsiStorage.layout()._batchHead.scanForward(tokenId); \n    }\n\n\n    function totalSupply() public virtual view returns (uint256) {\n        return _totalMinted();\n    }\n\n    /**\n     * @dev Returns an array of token IDs owned by `owner`.\n     *\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\n     * It is meant to be called off-chain.\n     *\n     * This function is compatiable with ERC721AQueryable.\n     */\n    function tokensOfOwner(address owner) external view virtual returns (uint256[] memory) {\n        unchecked {\n            uint256 tokenIdsIdx;\n            uint256 tokenIdsLength = balanceOf(owner);\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\n                if (_exists(i)) {\n                    if (ownerOf(i) == owner) {\n                        tokenIds[tokenIdsIdx++] = i;\n                    }\n                }\n            }\n            return tokenIds;   \n        }\n    }\n\n    /**\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     */\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\n     * minting.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     */\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n\n    /**\n     * @dev Returns the message sender (defaults to `msg.sender`).\n     *\n     * If you are writing GSN compatible contracts, you need to override this function.\n     */\n    function _msgSenderERC721Psi() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}","line":113,"range":[4197,4225]},"message":"reverted with custom error 'BalanceQueryForZeroAddress()'"}]}, code=CALL_EXCEPTION, version=providers/5.7.2)
  



